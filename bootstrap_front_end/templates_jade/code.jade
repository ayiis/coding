
.col-lg-10.col-lg-offset-2.mu-mt-42
    .col-lg-offset-1
        .row
            .col-lg-3
                h4 账号信息
                p 使用邮箱作为唯一帐号名

            .col-lg-9
                blockquote
                    footer 当前登陆身份：管理员
                    p ayiis@126.com

        hr
        .markdown
        hr
        | good

script(src="/js/showdown.min.js")
link(href="/css/solarized-light.css", rel="stylesheet")
script(src="/js/highlight.pack.js")
script.
    var converter = new showdown.Converter();
    var text = '\n```python\n#!/usr/bin/env python3 \n# -*- coding: utf-8 -*- \n"""\n    Build the .jade file into html recursively. \n    https://github.com/pugjs/pug \n    https://github.com/syrusakbary/pyjade \n \n    1. 将 jade 转为 html \n    2. 替换 html 里面的 <jade:*>*</jade:*> 标签 \n"""\nimport os \nimport re \nimport codecs \nfrom pathlib import Path \nfrom pyjade.ext.html import Compiler \nfrom pyjade.utils import process \n \n \nclass JadeWork: \n    """\n        1. 将 jade 转为 html 缓存到内存 _mem 中 \n        2. 解析所有 _mem 里的 <jade:*>*</jade:*> 标签 \n        3. 保存结果到文件 \n    """\n    _mem = {} \n    _reading = set({}) \n    _read = set({}) \n    _method = {"include", "break_jade", "raw"}   # 所有支持的 jade 语法标签，例如 jade:include header.jade \n \n    @classmethod \n    def _convert_jade(cls, jade_file): \n        """\n            读取 jade 文件并转化为 html 标签形式 \n        """\n        with codecs.open(jade_file, "r", encoding="utf-8") as rf: \n            return process(rf.read(), compiler=Compiler, staticAttrs=True, extension=None) \n \n    @classmethod \n    def _convert_dir_jade(cls, source_path, target_path): \n \n        if not Path(target_path).exists(): \n            os.makedirs(target_path) \n \n        for path in Path(source_path).glob("*"): \n \n            source_file = os.path.join(source_path, path.name) \n \n            if path.is_dir(): \n                cls._convert_dir_jade(source_file, "%s/%s" % (target_path, path.name)) \n            elif path.is_file(): \n                if path.name[-5:] == ".jade" and len(path.name) > 5: \n                    cls._mem[source_file] = cls._convert_jade(source_file) \n                else: \n                    print("Skip file in `_convert_dir_jade`: %s" % (source_file), flush=True) \n            else: \n                print("! Interesting path: %s" % path.name, flush=True) \n \n    @classmethod \n    def convert_dir_jade(cls, source_path, target_path): \n        """\n            解析 jade 并将结果缓存到 _mem 里 \n        """\n        if not Path(source_path).is_dir(): \n            raise Exception("%s must be a dir!" % source_path) \n \n        if not Path(target_path).exists(): \n            os.makedirs(target_path) \n        elif not Path(target_path).is_dir(): \n            raise Exception("%s must be a dir!" % target_path) \n \n        cls._convert_dir_jade(source_path, target_path) \n \n    @classmethod \n    def include(cls, source_file, source_path, target_path, text): \n        """\n            jade:include 语法解析，例如 \n            jade:include header.jade \n        """\n        target_path_dir = os.path.dirname(os.path.abspath(source_file)) \n        include_file = os.path.join(target_path_dir, text) \n        return cls._format_mem(include_file, source_path, target_path, source_file) \n \n    @classmethod \n    def break_jade(cls, source_file, source_path, target_path, text): \n        """\n            jade:break_jade 语法解析，例如 \n            jade:break_jade description \n        """\n        raise cls.BreakException \n \n    class BreakException(Exception): \n        """Break out of the statement"""\n        pass \n \n    @classmethod \n    def raw(cls, source_file, source_path, target_path, text): \n        """\n            jade:raw 语法解析，例如 \n            jade:raw </body> \n        """\n        return text \n \n    @classmethod \n    def handle_jade(cls, source_file, source_path, target_path): \n        """\n            jade:* 语法解析，对应类内的方法 \n        """\n        res = [] \n        regstr = "|".join([r"\<jade\:(%s)\>(.*)\</jade\:%s\>" % (x, x) for x in cls._method]) \n        for line in cls._mem[source_file].splitlines(): \n            reg_res = re.match(".*(?:%s).*" % regstr, line) \n            if reg_res: \n                method, text = [g for g in reg_res.groups() if g] \n                jade_method = getattr(cls, method) \n                try: \n                    jade_res = jade_method(source_file, source_path, target_path, text) \n                    res.append(jade_res) \n                except Exception as e: \n                    if type(e) == cls.BreakException: \n                        break \n \n            else: \n                res.append(line) \n \n        return "\\r\\n".join(res) \n \n    @classmethod \n    def _format_mem(cls, source_file, source_path, target_path, from_file=None): \n \n        # 如果当前文件还没完成上一次解析，说明存在循环引用 \n        if source_file in cls._reading: \n            raise Exception("Cyclic dependence found in %s" % (source_file)) \n \n        # 如果缓存 _mem 里不存在当前文件（上一步解析 jade 后会写入 _mem ），则说明当前文件不存在 \n        if source_file not in cls._mem: \n            raise Exception("%s not found when formatting %s" % (source_file, from_file)) \n \n        # 如果文件未解析，进行解析 \n        if source_file not in cls._read: \n \n            cls._reading.add(source_file) \n            cls._mem[source_file] = cls.handle_jade(source_file, source_path, target_path) \n            cls._reading.remove(source_file) \n            cls._read.add(source_file) \n \n        return cls._mem[source_file] \n \n    @classmethod \n    def format_mem(cls, source_path, target_path): \n        """\n            解析 _mem 里的 jade:* 标签 \n        """\n        for source_file in cls._mem: \n            cls._format_mem(source_file, source_path, target_path) \n \n    @classmethod \n    def write_result(cls, source_path, target_path): \n        """\n            将最终结果写入目标路径，同时去掉 .jade 的文件后缀名 \n        """\n        for source_file in cls._mem: \n            target_file = "%s%s" % (target_path, source_file[len(source_path):-5]) \n            with codecs.open(target_file, "w", encoding="utf-8") as wf: \n                wf.write(cls._mem[source_file]) \n \n    @classmethod \n    def build(cls, source_path, target_path): \n        """\n            1. 解析 jade 并将结果缓存到 _mem 里 \n            2. 解析 _mem 里的 jade:* 标签 \n            3. 将最终结果写入目标路径，同时去掉 .jade 的文件后缀名 \n        """\n        source_path = os.path.abspath(source_path) \n        target_path = os.path.abspath(target_path) \n \n        # 清理 \n        cls._mem = {} \n        cls._reading = set({}) \n        cls._read = set({}) \n \n        cls.convert_dir_jade(source_path, target_path) \n        cls.format_mem(source_path, target_path) \n        cls.write_result(source_path, target_path) \n \n        return cls._mem \n \n \nif __name__ == "__main__": \n    JadeWork.build("src", "src_html") \n```';
    var html = converter.makeHtml(text);
    $(".markdown").html(html);
    hljs.highlightAll();
